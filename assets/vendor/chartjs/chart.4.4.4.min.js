(function (global) {
  'use strict';

  function clone(value) {
    return value ? JSON.parse(JSON.stringify(value)) : value;
  }

  class MiniChart {
    constructor(context, config) {
      if (!context) {
        throw new Error('Chart requires a rendering context.');
      }
      this.canvas = context instanceof HTMLCanvasElement ? context : context.canvas;
      this.ctx = context instanceof CanvasRenderingContext2D ? context : this.canvas.getContext('2d');
      this.config = clone(config) || {};
      this.type = this.config.type || 'line';
      this.data = clone(this.config.data) || { labels: [], datasets: [] };
      this.options = clone(this.config.options) || {};
      this._plugins = Array.isArray(this.config.plugins) ? this.config.plugins : [];
      this._chartArea = null;
      this._scales = null;
      this._destroyed = false;
      this.devicePixelRatio = window.devicePixelRatio || 1;
      this.render();
    }

    update(newConfig) {
      if (newConfig) {
        this.config = clone(newConfig);
        this.type = newConfig.type || this.type;
        this.data = clone(newConfig.data) || this.data;
        this.options = clone(newConfig.options) || {};
        this._plugins = Array.isArray(newConfig.plugins) ? newConfig.plugins : [];
      }
      this.render();
    }

    destroy() {
      this._destroyed = true;
      this._clearCanvas();
    }

    render() {
      if (this._destroyed) {
        return;
      }
      this._resizeCanvas();
      this._clearCanvas();
      this._notifyPlugins('beforeDraw');
      if (this.type === 'bar') {
        this._drawBar();
      } else {
        this._drawLine();
      }
      this._notifyPlugins('afterDraw');
    }

    get ctx2d() {
      return this.ctx;
    }

    getPixelForValue(axis, value, index = 0) {
      if (!this._chartArea || !this._scales) {
        return null;
      }
      if (axis === 'y') {
        const clamped = Math.max(this._scales.y.min, Math.min(this._scales.y.max, value));
        const range = this._chartArea.bottom - this._chartArea.top;
        const ratio = (clamped - this._scales.y.min) / (this._scales.y.max - this._scales.y.min || 1);
        return this._chartArea.bottom - ratio * range;
      }
      if (axis === 'x') {
        if (this.type === 'bar') {
          const groupWidth = (this._chartArea.right - this._chartArea.left) / Math.max(this.data.labels.length, 1);
          return this._chartArea.left + groupWidth * index + groupWidth / 2;
        }
        const step = this.data.labels.length > 1
          ? (this._chartArea.right - this._chartArea.left) / (this.data.labels.length - 1)
          : 0;
        return this.data.labels.length > 1
          ? this._chartArea.left + step * index
          : this._chartArea.left + (this._chartArea.right - this._chartArea.left) / 2;
      }
      return null;
    }

    _resizeCanvas() {
      const ratio = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      const width = rect.width || this.canvas.width || 640;
      const height = rect.height || this.canvas.height || 320;
      if (this.canvas.width !== width * ratio || this.canvas.height !== height * ratio) {
        this.canvas.width = width * ratio;
        this.canvas.height = height * ratio;
      }
      this.canvas.style.width = `${width}px`;
      this.canvas.style.height = `${height}px`;
      this.devicePixelRatio = ratio;
      this.ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      this.width = width;
      this.height = height;
    }

    _clearCanvas() {
      this.ctx.save();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.restore();
      this.ctx.setTransform(this.devicePixelRatio, 0, 0, this.devicePixelRatio, 0, 0);
      this.ctx.font = `${MiniChart.defaults.font.weight} ${MiniChart.defaults.font.size}px ${MiniChart.defaults.font.family}`;
      this.ctx.fillStyle = MiniChart.defaults.color;
      this.ctx.strokeStyle = MiniChart.defaults.axisColor;
      this.ctx.lineWidth = 1;
    }

    _notifyPlugins(hook) {
      const plugins = MiniChart._plugins.concat(this._plugins);
      plugins.forEach((plugin) => {
        if (plugin && typeof plugin[hook] === 'function') {
          plugin[hook](this);
        }
      });
    }

    _prepareScales(allValues) {
      const areaPadding = this.options.layout?.padding || { left: 54, right: 28, top: 26, bottom: 48 };
      const left = areaPadding.left ?? 54;
      const right = this.width - (areaPadding.right ?? 28);
      const top = areaPadding.top ?? 26;
      const bottom = this.height - (areaPadding.bottom ?? 48);
      const beginAtZero = this.options.scales?.y?.beginAtZero;
      const suggestedMax = this.options.scales?.y?.suggestedMax;
      const min = beginAtZero ? 0 : Math.min(...allValues);
      const maxCandidate = Math.max(...allValues, suggestedMax || 0);
      const max = maxCandidate === 0 ? 1 : maxCandidate * 1.08;
      this._chartArea = { left, right, top, bottom };
      this._scales = {
        y: {
          min,
          max,
          range: max - min || 1
        },
        x: {
          count: this.data.labels.length
        }
      };
    }

    _drawYAxis() {
      const ctx = this.ctx;
      const area = this._chartArea;
      const tickConfig = this.options.scales?.y?.ticks || {};
      const tickCount = tickConfig.count ?? 4;
      const formatter = typeof tickConfig.callback === 'function' ? tickConfig.callback : (value) => {
        return Number.isInteger(value) ? value.toString() : value.toFixed(1);
      };
      const steps = Math.max(1, tickCount);
      ctx.save();
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = MiniChart.defaults.tickColor;
      ctx.strokeStyle = MiniChart.defaults.gridColor;
      ctx.lineWidth = 1;
      for (let i = 0; i <= steps; i += 1) {
        const ratio = i / steps;
        const value = this._scales.y.max - this._scales.y.range * ratio;
        const y = area.top + (area.bottom - area.top) * ratio;
        ctx.beginPath();
        ctx.moveTo(area.left, y);
        ctx.lineTo(area.right, y);
        ctx.stroke();
        ctx.fillText(formatter(value), area.left - 12, y);
      }
      ctx.restore();
      ctx.save();
      ctx.strokeStyle = MiniChart.defaults.axisColor;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(area.left, area.top);
      ctx.lineTo(area.left, area.bottom);
      ctx.lineTo(area.right, area.bottom);
      ctx.stroke();
      ctx.restore();
    }

    _drawXAxis(labels, isBar) {
      const ctx = this.ctx;
      const area = this._chartArea;
      const count = labels.length;
      if (!count) {
        return;
      }
      ctx.save();
      ctx.fillStyle = MiniChart.defaults.tickColor;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      if (isBar) {
        const groupWidth = (area.right - area.left) / Math.max(count, 1);
        labels.forEach((label, index) => {
          const x = area.left + groupWidth * index + groupWidth / 2;
          ctx.fillText(label, x, area.bottom + 12);
        });
      } else {
        const step = count > 1 ? (area.right - area.left) / (count - 1) : 0;
        labels.forEach((label, index) => {
          const x = count > 1 ? area.left + step * index : area.left + (area.right - area.left) / 2;
          ctx.fillText(label, x, area.bottom + 12);
        });
      }
      ctx.restore();
    }

    _drawLine() {
      const datasets = Array.isArray(this.data.datasets) ? this.data.datasets : [];
      const labels = Array.isArray(this.data.labels) ? this.data.labels : [];
      if (!datasets.length || !labels.length) {
        return;
      }
      const numericValues = [];
      datasets.forEach((dataset) => {
        (dataset.data || []).forEach((value) => {
          if (typeof value === 'number' && !Number.isNaN(value)) {
            numericValues.push(value);
          }
        });
      });
      if (!numericValues.length) {
        return;
      }
      this._prepareScales(numericValues);
      this._drawYAxis();
      const area = this._chartArea;
      const step = labels.length > 1 ? (area.right - area.left) / (labels.length - 1) : 0;
      this._xPositions = labels.map((_, index) => {
        return labels.length > 1 ? area.left + step * index : area.left + (area.right - area.left) / 2;
      });
      datasets.forEach((dataset) => {
        const values = dataset.data || [];
        const points = values.map((value, index) => {
          if (typeof value !== 'number' || Number.isNaN(value)) {
            return null;
          }
          return {
            x: this._xPositions[index],
            y: this.getPixelForValue('y', value),
            value
          };
        });
        const showLine = dataset.showLine !== false;
        if (showLine) {
          this.ctx.save();
          this.ctx.lineWidth = dataset.borderWidth ?? 2;
          this.ctx.strokeStyle = dataset.borderColor || '#4fa3ff';
          this.ctx.setLineDash(dataset.borderDash || []);
          this.ctx.beginPath();
          points.forEach((point, index) => {
            if (!point) {
              return;
            }
            if (index === 0 || !points[index - 1]) {
              this.ctx.moveTo(point.x, point.y);
            } else {
              this.ctx.lineTo(point.x, point.y);
            }
          });
          this.ctx.stroke();
          this.ctx.restore();
        }
        const radius = dataset.pointRadius != null ? dataset.pointRadius : 4;
        if (radius > 0) {
          this.ctx.save();
          this.ctx.fillStyle = dataset.pointBackgroundColor || dataset.borderColor || '#ffffff';
          this.ctx.strokeStyle = dataset.pointBorderColor || 'rgba(6, 10, 22, 0.65)';
          this.ctx.lineWidth = dataset.pointBorderWidth || 1;
          points.forEach((point) => {
            if (!point) {
              return;
            }
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
            this.ctx.fill();
            if (this.ctx.lineWidth > 0) {
              this.ctx.stroke();
            }
          });
          this.ctx.restore();
        }
      });
      this._drawXAxis(labels, false);
    }

    _drawBar() {
      const datasets = Array.isArray(this.data.datasets) ? this.data.datasets : [];
      const labels = Array.isArray(this.data.labels) ? this.data.labels : [];
      if (!datasets.length || !labels.length) {
        return;
      }
      const numericValues = [];
      datasets.forEach((dataset) => {
        (dataset.data || []).forEach((value) => {
          if (typeof value === 'number' && !Number.isNaN(value)) {
            numericValues.push(value);
          }
        });
      });
      if (!numericValues.length) {
        return;
      }
      this._prepareScales(numericValues);
      this._drawYAxis();
      const area = this._chartArea;
      const groupCount = labels.length;
      const groupWidth = groupCount ? (area.right - area.left) / groupCount : 0;
      const datasetCount = datasets.length || 1;
      const gap = 12;
      const usableWidth = Math.max(groupWidth - gap, 12);
      const barWidth = usableWidth / datasetCount;
      datasets.forEach((dataset, datasetIndex) => {
        const values = dataset.data || [];
        values.forEach((value, groupIndex) => {
          if (typeof value !== 'number' || Number.isNaN(value)) {
            return;
          }
          const baseX = area.left + groupWidth * groupIndex + gap / 2;
          const x = baseX + barWidth * datasetIndex;
          const width = Math.max(barWidth - 6, 6);
          const adjustedX = x + (barWidth - width) / 2;
          const y = this.getPixelForValue('y', value);
          const bottom = this.getPixelForValue('y', this._scales.y.min);
          this.ctx.save();
          this.ctx.fillStyle = Array.isArray(dataset.backgroundColor)
            ? dataset.backgroundColor[groupIndex % dataset.backgroundColor.length]
            : dataset.backgroundColor || '#4fa3ff';
          this.ctx.beginPath();
          this.ctx.moveTo(adjustedX, bottom);
          this.ctx.lineTo(adjustedX, y);
          this.ctx.lineTo(adjustedX + width, y);
          this.ctx.lineTo(adjustedX + width, bottom);
          this.ctx.closePath();
          this.ctx.fill();
          this.ctx.restore();
        });
      });
      this._drawXAxis(labels, true);
    }
  }

  MiniChart._plugins = [];
  MiniChart.defaults = {
    color: 'rgba(226, 232, 240, 0.88)',
    tickColor: 'rgba(226, 232, 240, 0.75)',
    gridColor: 'rgba(148, 163, 184, 0.18)',
    axisColor: 'rgba(148, 163, 184, 0.45)',
    font: {
      family: 'Inter, "Segoe UI", system-ui, sans-serif',
      size: 14,
      weight: '400'
    }
  };

  MiniChart.register = function registerPlugin(...plugins) {
    plugins.forEach((plugin) => {
      if (plugin && !MiniChart._plugins.includes(plugin)) {
        MiniChart._plugins.push(plugin);
      }
    });
  };

  MiniChart.version = '4.4.4-lite';

  global.Chart = MiniChart;
})(window);
