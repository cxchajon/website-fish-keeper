<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-KTRVCMQN');</script>
  <!-- End Google Tag Manager -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://thetankguide.com/assets/img/logos/logo-1200x630.png" />
  <meta name="twitter:image:alt" content="FishKeepingLifeCo logo (1200√ó630)." />
  <meta property="og:image" content="https://thetankguide.com/assets/img/logos/logo-1200x630.png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:image:alt" content="FishKeepingLifeCo logo (1200√ó630)." />
  <link rel="preload" href="/footer.html?v=1.5.2" as="fetch" crossorigin="anonymous">
  <meta charset="UTF-8" />
  <meta property="og:site_name" content="The Tank Guide" />
  <!-- Consent Mode defaults (runs after GA loader) -->
  <script src="/assets/js/consent-mode.js" defer></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Aquarium Journal Dashboard ‚Äî The Tank Guide</title>
  <meta name="description" content="Internal aquarium tracker that visualizes nitrate, dosing, and feeding logs used for Tank Guide editorial experiments." />
  <meta name="robots" content="noindex,nofollow" />
  <link rel="canonical" href="https://thetankguide.com/journal-dashboard.html" />
  <!-- NOINDEX: internal dashboard, not for public indexing -->

  <!-- Chart.js + Datalabels -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>

  <style>
    /* ====== Base / Background ====== */
    .journal-dashboard *,
    .journal-dashboard *::before,
    .journal-dashboard *::after { margin:0; padding:0; box-sizing:border-box; }
    body.journal-dashboard{
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background:#0a0e1a;
      color:#e4e6eb;
      padding:20px;
      padding-bottom:80px; /* keep footer clear */
      background-image:
        linear-gradient(rgba(30,144,255,.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(30,144,255,.05) 1px, transparent 1px);
      background-size:50px 50px;
    }

    /* ====== Header ====== */
    .journal-dashboard .dashboard-header{
      text-align:center;
      margin-bottom:40px;
      padding:30px;
      background:linear-gradient(135deg,#1a2332 0%, #0f1620 100%);
      border-radius:15px;
      border:1px solid rgba(30,144,255,.2);
      box-shadow:0 8px 32px rgba(0,0,0,.4);
    }
    .journal-dashboard .dashboard-header h1{
      font-size:2.4rem;
      margin-bottom:10px;
      background:linear-gradient(90deg,#1e90ff,#00bfff);
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
    }
    .journal-dashboard .dashboard-header p{ color:#8b9dc3; font-size:1.05rem; }
    .journal-dashboard .dashboard-header .header-links{
      margin-top:15px;
      display:flex;
      justify-content:center;
      gap:20px;
      flex-wrap:wrap;
    }
    .journal-dashboard .dashboard-header .header-links a{
      color:#3aa6ff;
      text-decoration:none;
      font-size:0.95rem;
      padding:8px 16px;
      border:1px solid rgba(58,166,255,0.3);
      border-radius:6px;
      transition:all 0.2s;
    }
    .journal-dashboard .dashboard-header .header-links a:hover{
      background:rgba(58,166,255,0.1);
      border-color:rgba(58,166,255,0.6);
    }
    .journal-dashboard .sync-status{
      font-size:0.85rem;
      color:#6b7c99;
      margin-top:10px;
    }
    .journal-dashboard .sync-status.loading{ color:#ffd700; }
    .journal-dashboard .sync-status.error{ color:#ff6b6b; }
    .journal-dashboard .sync-status.success{ color:#51cf66; }

    /* ====== Data Quality Indicator ====== */
    .journal-dashboard .data-quality{
      background:linear-gradient(135deg,#1a2332 0%, #0f1620 100%);
      padding:20px;
      border-radius:12px;
      border:1px solid rgba(30,144,255,.3);
      box-shadow:0 4px 16px rgba(0,0,0,.3);
      margin-bottom:40px;
    }
    .journal-dashboard .data-quality h3{
      color:#1e90ff;
      font-size:1.1rem;
      margin-bottom:12px;
    }
    .journal-dashboard .quality-item{
      display:flex;
      align-items:center;
      gap:8px;
      margin-bottom:8px;
      font-size:0.9rem;
    }
    .journal-dashboard .quality-item .icon{ font-size:1rem; }
    .journal-dashboard .quality-item.good .icon{ color:#51cf66; }
    .journal-dashboard .quality-item.warn .icon{ color:#ffd700; }
    .journal-dashboard .quality-item.info .icon{ color:#3aa6ff; }

    /* ====== Stats ====== */
    .journal-dashboard .dashboard-grid{
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(220px,1fr));
      gap:20px;
      margin-bottom:40px;
    }
    .journal-dashboard .dashboard-card{
      background:linear-gradient(135deg,#1a2332 0%, #0f1620 100%);
      padding:20px;
      border-radius:12px;
      border:1px solid rgba(30,144,255,.3);
      box-shadow:0 4px 16px rgba(0,0,0,.3);
      transition:transform .2s, box-shadow .2s;
    }
    .journal-dashboard .dashboard-card:hover{ transform:translateY(-4px); box-shadow:0 8px 20px rgba(30,144,255,.25); }
    .journal-dashboard .dashboard-label{ color:#8b9dc3; font-size:.9rem; margin-bottom:8px; text-transform:uppercase; letter-spacing:.06em; }
    .journal-dashboard .dashboard-value{ font-size:2rem; font-weight:700; color:#1e90ff; }
    .journal-dashboard .dashboard-subtext{ color:#6b7c99; font-size:.85rem; margin-top:6px; }

    /* ====== Charts ====== */
    .journal-dashboard .chart-grid{
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(520px,1fr));
      gap:25px;
      margin-bottom:40px;
    }
    .journal-dashboard .chart-card{
      background:linear-gradient(135deg,#1a2332 0%, #0f1620 100%);
      padding:24px;
      border-radius:12px;
      border:1px solid rgba(30,144,255,.3);
      box-shadow:0 4px 16px rgba(0,0,0,.3);
    }
    .journal-dashboard .chart-card h2{
      color:#1e90ff;
      font-size:1.25rem;
      margin-bottom:14px;
      border-bottom:2px solid rgba(30,144,255,.2);
      padding-bottom:8px;
    }
    .journal-dashboard .chart-wrapper{ position:relative; height:400px; }
    .journal-dashboard .full-width{ grid-column:1 / -1; }

    /* ====== Custom Tooltip ====== */
    .journal-dashboard .chart-tooltip{
      position:absolute;
      background:rgba(15,22,32,0.98);
      border:1px solid rgba(58,166,255,0.5);
      border-radius:8px;
      padding:12px 16px;
      max-width:320px;
      font-size:0.85rem;
      pointer-events:none;
      opacity:0;
      transition:opacity 0.2s;
      z-index:1000;
      box-shadow:0 8px 24px rgba(0,0,0,0.5);
    }
    .journal-dashboard .chart-tooltip.visible{ opacity:1; pointer-events:auto; }
    .journal-dashboard .chart-tooltip .tooltip-date{
      color:#3aa6ff;
      font-weight:700;
      margin-bottom:8px;
    }
    .journal-dashboard .chart-tooltip .tooltip-value{
      color:#e4e6eb;
      font-size:1.1rem;
      font-weight:600;
      margin-bottom:8px;
    }
    .journal-dashboard .chart-tooltip .tooltip-snippet{
      color:#9bb0cc;
      font-size:0.8rem;
      line-height:1.4;
      margin-bottom:8px;
      font-style:italic;
    }
    .journal-dashboard .chart-tooltip .tooltip-link{
      color:#3aa6ff;
      font-size:0.75rem;
      text-decoration:none;
    }
    .journal-dashboard .chart-tooltip .tooltip-link:hover{ text-decoration:underline; }

    /* ====== Timelines ====== */
    .journal-dashboard .timeline-section{
      background:linear-gradient(135deg,#1a2332 0%, #0f1620 100%);
      padding:25px;
      border-radius:12px;
      border:1px solid rgba(30,144,255,.3);
      box-shadow:0 4px 16px rgba(0,0,0,.3);
      margin-bottom:40px;
    }
    .journal-dashboard .timeline-section h2{
      color:#1e90ff;
      margin-bottom:15px;
      border-bottom:2px solid rgba(30,144,255,.2);
      padding-bottom:8px;
    }
    .journal-dashboard .timeline-item{
      background:rgba(30,144,255,.05);
      border-left:4px solid #1e90ff;
      padding:15px;
      margin-bottom:12px;
      border-radius:8px;
    }
    .journal-dashboard .timeline-date{ color:#1e90ff; font-weight:700; margin-bottom:5px; }
    .journal-dashboard .timeline-type{
      display:inline-block; background:#1e90ff; color:#0a0e1a;
      padding:4px 10px; border-radius:5px; font-size:.85rem; font-weight:700; margin-bottom:8px;
    }
    .journal-dashboard .timeline-content{ color:#c4c8d0; line-height:1.6; }
    .journal-dashboard .milestone{ background:rgba(255,215,0,.1); border-left-color:#ffd700; }
    .journal-dashboard .milestone .timeline-type{ background:#ffd700; }
    .journal-dashboard .timeline-link{
      display:inline-block;
      margin-top:8px;
      color:#3aa6ff;
      font-size:0.8rem;
      text-decoration:none;
    }
    .journal-dashboard .timeline-link:hover{ text-decoration:underline; }

    /* ====== Screen reader only ====== */
    .journal-dashboard .sr-only{
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }

    /* ====== Responsive ====== */
    @media (max-width: 1024px){
      .journal-dashboard .chart-wrapper{ height:360px; }
    }
    @media (max-width: 768px){
      .journal-dashboard .chart-grid{ grid-template-columns:1fr; }
      .journal-dashboard .chart-wrapper{ height:320px; }
      .journal-dashboard .dashboard-header h1{ font-size:1.9rem; }
      .journal-dashboard .chart-tooltip{ max-width:280px; }
    }
    @media (max-width: 480px){
      body.journal-dashboard{ padding:12px; }
      .journal-dashboard .dashboard-header{ padding:20px; }
      .journal-dashboard .dashboard-header h1{ font-size:1.6rem; }
      .journal-dashboard .chart-card{ padding:16px; }
      .journal-dashboard .chart-wrapper{ height:280px; }
    }
</style>
  <!-- Consent Mode defaults (load FIRST) -->
  <script src="/assets/js/consent-mode.js" defer></script>
  <!-- --- Google CMP (Funding Choices) START --- -->
  <script async src="https://fundingchoicesmessages.google.com/i/pub-9905718149811880?ers=1"></script>
  <script>
    // Required bootstrap per Google; signals CMP presence
    (function() {
      function signalGooglefcPresent() {
        if (!window.frames['googlefcPresent']) {
          if (document.body) {
            const iframe = document.createElement('iframe');
            iframe.style.cssText = 'display:none';
            iframe.name = 'googlefcPresent';
            document.body.appendChild(iframe);
          } else {
            setTimeout(signalGooglefcPresent, 0);
          }
        }
      }
      signalGooglefcPresent();
    })();
  </script>
  <!-- --- Google CMP (Funding Choices) END --- -->
</head>

<body class="journal-dashboard">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KTRVCMQN"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  <script defer src="/js/nav.js?v=1.1.0"></script>
  <a class="skip-link" href="#main-content">Skip to main content</a>
  <div id="site-nav"></div>
  <main id="main-content">
  <div class="dashboard-header">
    <h1>Aquarium Monitoring Dashboard</h1>
    <p>Auto-synced from Live Tank Journal</p>
    <div class="header-links">
      <a href="/journal.html">View Full Journal</a>
    </div>
    <div id="syncStatus" class="sync-status loading">Loading data...</div>
  </div>

  <!-- ====== DATA QUALITY INDICATOR ====== -->
  <div class="data-quality" id="dataQuality" role="region" aria-label="Data quality metrics">
    <h3>Data Completeness</h3>
    <div id="qualityMetrics">
      <div class="quality-item info">
        <span class="icon" aria-hidden="true">...</span>
        <span>Loading data quality metrics...</span>
      </div>
    </div>
  </div>

  <!-- ====== STATS ====== -->
  <div class="dashboard-grid">
    <div class="dashboard-card">
      <div class="dashboard-label">Current Nitrate</div>
      <div class="dashboard-value" id="currentNitrate">‚Äî</div>
      <div class="dashboard-subtext">ppm</div>
    </div>
    <div class="dashboard-card">
      <div class="dashboard-label">Days Since WC</div>
      <div class="dashboard-value" id="daysSinceWC">‚Äî</div>
      <div class="dashboard-subtext" id="lastWCSub">Last: ‚Äî</div>
    </div>
    <div class="dashboard-card">
      <div class="dashboard-label">Total Feedings</div>
      <div class="dashboard-value" id="totalFeedings">‚Äî</div>
      <div class="dashboard-subtext">Since Sep 9</div>
    </div>
    <div class="dashboard-card">
      <div class="dashboard-label">System Status</div>
      <div class="dashboard-value" style="font-size:1.5rem;">‚úì Stable</div>
      <div class="dashboard-subtext">Post-maintenance</div>
    </div>
  </div>

  <!-- ====== CHARTS ====== -->
  <div class="chart-grid">
    <div class="chart-card full-width" role="region" aria-label="Nitrate levels chart">
      <h2>Nitrate Levels Over Time</h2>
      <div class="chart-wrapper">
        <canvas id="nitrateChart" aria-describedby="nitrate-summary"></canvas>
        <div id="nitrate-summary" class="sr-only">
          Chart showing nitrate levels over time from aquarium water tests.
        </div>
        <div id="nitrateTooltip" class="chart-tooltip" role="tooltip"></div>
      </div>
    </div>

    <div class="chart-card" role="region" aria-label="Feeding distribution chart">
      <h2>Feeding Distribution</h2>
      <div class="chart-wrapper">
        <canvas id="feedingChart" aria-describedby="feeding-summary"></canvas>
        <div id="feeding-summary" class="sr-only">
          Doughnut chart showing distribution of feeding types.
        </div>
      </div>
    </div>

    <div class="chart-card" role="region" aria-label="Dosing frequency chart">
      <h2>Dosing Frequency</h2>
      <div class="chart-wrapper">
        <canvas id="dosingChart" aria-describedby="dosing-summary"></canvas>
        <div id="dosing-summary" class="sr-only">
          Bar chart showing frequency of different dosing products.
        </div>
      </div>
    </div>

    <div class="chart-card full-width" role="region" aria-label="Activity timeline chart">
      <h2>Daily Activity Timeline</h2>
      <div class="chart-wrapper">
        <canvas id="activityChart" aria-describedby="activity-summary"></canvas>
        <div id="activity-summary" class="sr-only">
          Bar chart showing total activities per day across all recorded dates.
        </div>
      </div>
    </div>
  </div>

  <!-- ====== TIMELINES ====== -->
  <div class="timeline-section">
    <h2>üéØ Recent Milestones & Key Events</h2>
    <div id="milestones"></div>
  </div>

  <div class="timeline-section">
    <h2>üìù Recent Activity Log</h2>
    <div id="recentActivity"></div>
  </div>

  <script>
    // ====== JOURNAL DASHBOARD V2 ‚Äî AUTO-SYNC ENGINE ======

    // ====== CONFIGURATION ======
    const CONFIG = {
      indexUrl: '/data/journal/index.json',
      dataBasePath: '/data/journal/',
      cacheTimeout: 300000, // 5 minutes
      journalBaseUrl: '/journal.html'
    };

    // ====== UTILITY FUNCTIONS ======
    const fmtDate = (iso) => {
      try {
        const [y, m, d] = iso.split('-');
        return `${m}/${d}`;
      } catch { return iso; }
    };

    const fmtFullDate = (iso) => {
      try {
        const date = new Date(iso + 'T00:00:00');
        return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
      } catch { return iso; }
    };

    const getMonthFromDate = (iso) => {
      try {
        return iso.substring(0, 7);
      } catch { return ''; }
    };

    // ====== NATURAL LANGUAGE PARSING ENGINE ======

    // Extract nitrate value from text
    function extractNitrate(text) {
      if (!text) return null;

      const patterns = [
        // "Nitrate: 5 ppm" or "Nitrate 5 ppm"
        /nitrate[s]?\s*(?::|tested|measured|registered|came\s+in|at|around)?\s*(?:at|around)?\s*[<‚â§]?(\d+)(?:\s*[-‚Äì‚Äî]\s*\d+)?\s*(?:ppm)?/i,
        // "5-10 ppm (closer to 5)" or "10‚Äì20 ppm (‚âà20)"
        /(\d+)\s*[-‚Äì‚Äî]\s*\d+\s*ppm\s*\((?:closer\s+to\s+|[‚âà~])?(\d+)\)/i,
        // "~10 ppm" or "‚âà20 ppm"
        /[~‚âà]\s*(\d+)\s*ppm/i,
        // "<5 ppm" or "‚â§5 ppm"
        /[<‚â§]\s*(\d+)\s*ppm/i,
        // Fallback: "X ppm" pattern
        /(\d+)\s*ppm/i
      ];

      for (let pattern of patterns) {
        const match = text.match(pattern);
        if (match) {
          // If range with preference (e.g., "10-20 (closer to 20)")
          if (match[2]) return parseFloat(match[2]);
          // If single value
          if (match[1]) return parseFloat(match[1]);
        }
      }
      return null;
    }

    // Extract feeding type from text
    function extractFeeding(text) {
      if (!text) return null;

      const lowerText = text.toLowerCase();

      // Check for skipped feeding first
      if (/(?:skipped|no)\s*feeding|fed:\s*none/i.test(text)) {
        return 'none';
      }

      // Common feeding patterns
      const feedingPatterns = [
        { pattern: /(?:algae\s*)?wafers?\s*(?:and|\+|with)?\s*(?:light\s*)?flakes?/i, type: 'algae wafers + flakes' },
        { pattern: /flakes?\s*(?:and|\+|with)?\s*(?:algae\s*)?wafers?/i, type: 'flakes + algae wafers' },
        { pattern: /flakes?\s*(?:and|\+|with)?\s*brine\s*shrimp\s*(?:and|\+|with)?\s*bloodworms?/i, type: 'flakes + brine shrimp + bloodworms' },
        { pattern: /flakes?\s*(?:and|\+|with)?\s*bloodworms?/i, type: 'flakes + bloodworms' },
        { pattern: /flakes?\s*(?:and|\+|with)?\s*brine\s*shrimp/i, type: 'flakes + brine shrimp' },
        { pattern: /brine\s*shrimp\s*(?:and|\+|with)?\s*flakes?/i, type: 'flakes + brine shrimp' },
        { pattern: /algae\s*wafers?\s*(?:and|\+|with)?\s*brine\s*shrimp\s*(?:and|\+|with)?\s*bloodworms?/i, type: 'algae wafers + brine shrimp + bloodworms' },
        { pattern: /veggie[\s-]*only|zucchini|spinach/i, type: 'veggie-only (zucchini/spinach or wafers)' },
        { pattern: /flakes?\s*only/i, type: 'flakes only' }
      ];

      for (let { pattern, type } of feedingPatterns) {
        if (pattern.test(text)) return type;
      }

      // Look for "Fed: X" pattern in quick_facts
      const fedMatch = text.match(/fed[:\s]+([^¬∑]+)/i);
      if (fedMatch) return fedMatch[1].trim().toLowerCase();

      return 'unspecified';
    }

    // Extract dosing information from text
    function extractDosing(text) {
      if (!text) return [];

      const dosings = [];

      // NilocG Thrive Plus patterns
      const thriveMatch = text.match(/(?:nilocg\s*)?thrive\s*(?:plus)?[^¬∑]*?(\d+)\s*pumps?/i);
      if (thriveMatch) {
        dosings.push({
          product: 'NilocG Thrive Plus',
          amount: `${thriveMatch[1]} pumps`,
          detail: thriveMatch[0].trim()
        });
      }

      // Seachem Excel patterns
      const excelPatterns = [
        /seachem\s*excel[^¬∑]*?(\d+)\s*capfuls?/i,
        /seachem\s*excel[^¬∑]*?(spot\s*(?:dose|treatment|and|\+|with)?(?:\s*x\d+)?(?:\s*\+?\s*\d*\s*cap(?:ful)?)?)/i,
        /excel[^¬∑]*?(spot|capful|cap)/i
      ];

      for (let pattern of excelPatterns) {
        const match = text.match(pattern);
        if (match) {
          dosings.push({
            product: 'Seachem Excel',
            amount: match[1],
            detail: match[0].trim()
          });
          break;
        }
      }

      // Seachem Stability
      if (/stability/i.test(text)) {
        dosings.push({
          product: 'Seachem Stability',
          amount: 'dose',
          detail: 'Stability dose'
        });
      }

      return dosings;
    }

    // Classify entry types from content
    function classifyEntry(entry) {
      const types = new Set();
      const text = getEntryText(entry).toLowerCase();
      const category = (entry.category || entry.title || '').toLowerCase();

      if (/feeding|fed|food|flakes|wafers|bloodworms|brine\s*shrimp/i.test(text) || /feeding/i.test(category)) {
        types.add('Feeding');
      }
      if (/nitrate|test|parameter|ppm/i.test(text) || /test/i.test(category)) {
        types.add('Parameters');
      }
      if (/dos(?:e|ing)|excel|thrive|fertilizer|stability/i.test(text) || /dosing/i.test(category)) {
        types.add('Dosing');
      }
      if (/water\s*change|maintenance|clean|trim|wc|poly-?fil|purigen/i.test(text) || /maintenance/i.test(category)) {
        types.add('Maintenance');
      }
      if (/observation|discover|notice|behavior|milestone/i.test(text) || /observation/i.test(category)) {
        types.add('Observation');
      }
      if (/checkpoint/i.test(category)) {
        types.add('Checkpoint');
      }

      return Array.from(types);
    }

    // Get combined text from entry (handles both old and new format)
    function getEntryText(entry) {
      if (entry.body) {
        return `${entry.title || ''} ${entry.body}`;
      }
      return `${entry.category || ''} ${entry.quick_facts || ''} ${entry.ramble || ''}`;
    }

    // Get entry snippet for tooltips
    function getEntrySnippet(entry, maxLength = 120) {
      const text = entry.body || entry.ramble || entry.quick_facts || '';
      if (text.length <= maxLength) return text;
      return text.substring(0, maxLength).trim() + '...';
    }

    // Parse a single journal entry
    function parseJournalEntry(entry) {
      const text = getEntryText(entry);
      const types = classifyEntry(entry);

      // Extract nitrate - first check structured field, then parse text
      let nitrate = null;
      if (entry.nitrate_ppm && entry.nitrate_ppm !== '') {
        const parsed = parseFloat(entry.nitrate_ppm.replace(/[<‚â§~‚âà]/g, ''));
        if (!isNaN(parsed)) nitrate = parsed;
      }
      if (nitrate === null) {
        nitrate = extractNitrate(text);
      }

      // Extract feeding
      let feeding = null;
      if (types.includes('Feeding')) {
        feeding = extractFeeding(text);
      }

      // Extract dosing
      const dosing = extractDosing(text);

      // Determine if it's a milestone
      const isMilestone = /milestone|checkpoint|observation\s*week|recovery\s*week|pre-?stocking/i.test(text);

      return {
        date: entry.date,
        title: entry.title || entry.category || '',
        body: entry.body || entry.ramble || '',
        quickFacts: entry.quick_facts || '',
        types: types,
        nitrate: nitrate,
        feeding: feeding,
        dosing: dosing,
        isMilestone: isMilestone,
        tags: entry.tags || '',
        month: getMonthFromDate(entry.date),
        snippet: getEntrySnippet(entry),
        originalEntry: entry
      };
    }

    // ====== DATA FETCHING & CACHING ======

    async function fetchWithCache(url) {
      const cacheKey = `journal-cache-${url}`;
      const cached = sessionStorage.getItem(cacheKey);

      if (cached) {
        try {
          const { timestamp, data } = JSON.parse(cached);
          if (Date.now() - timestamp < CONFIG.cacheTimeout) {
            return { data, fromCache: true };
          }
        } catch (e) {
          sessionStorage.removeItem(cacheKey);
        }
      }

      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch ${url}: ${response.status}`);
      }

      const data = await response.json();

      // Cache the result
      try {
        sessionStorage.setItem(cacheKey, JSON.stringify({
          timestamp: Date.now(),
          data: data
        }));
      } catch (e) {
        // Storage full, continue without caching
      }

      return { data, fromCache: false };
    }

    async function fetchAllJournalData() {
      const statusEl = document.getElementById('syncStatus');
      statusEl.className = 'sync-status loading';
      statusEl.textContent = 'Fetching journal data...';

      console.log('[Dashboard] Initializing data fetch...');
      console.log('[Dashboard] Index URL:', CONFIG.indexUrl);

      try {
        // Fetch index to get available months
        console.log('[Dashboard] Fetching index file...');
        const { data: months } = await fetchWithCache(CONFIG.indexUrl);
        console.log('[Dashboard] Index loaded, available months:', months);

        if (!months || months.length === 0) {
          throw new Error('No months found in index.json');
        }

        // Fetch all month files in parallel
        console.log('[Dashboard] Fetching month files in parallel...');
        const fetchPromises = months.map(month => {
          const url = `${CONFIG.dataBasePath}${month}.json`;
          console.log('[Dashboard] Fetching:', url);
          return fetchWithCache(url)
            .then(result => {
              console.log(`[Dashboard] ${month}.json loaded:`, result.data.length, 'entries', result.fromCache ? '(cached)' : '(fresh)');
              return { month, ...result };
            })
            .catch(err => {
              console.error(`[Dashboard] Failed to load ${month}.json:`, err.message);
              return { month, data: [], error: err };
            });
        });

        const results = await Promise.all(fetchPromises);

        // Combine all entries
        let allEntries = [];
        let loadedMonths = [];
        let failedMonths = [];

        results.forEach(result => {
          if (result.error) {
            failedMonths.push(result.month);
          } else {
            loadedMonths.push(result.month);
            allEntries = allEntries.concat(result.data);
          }
        });

        console.log('[Dashboard] Total raw entries:', allEntries.length);
        console.log('[Dashboard] Loaded months:', loadedMonths);
        console.log('[Dashboard] Failed months:', failedMonths);

        if (allEntries.length === 0) {
          statusEl.className = 'sync-status error';
          statusEl.textContent = 'No data available. Check that JSON files exist in /data/journal/';
          console.error('[Dashboard] No entries loaded from any month file');
          return null;
        }

        // Sort by date (oldest first for charts)
        allEntries.sort((a, b) => a.date.localeCompare(b.date));

        // Parse all entries
        const parsedEntries = allEntries.map(parseJournalEntry);

        // Count parsed data
        const nitrateCount = parsedEntries.filter(e => e.nitrate !== null).length;
        const feedingCount = parsedEntries.filter(e => e.types.includes('Feeding')).length;
        const dosingCount = parsedEntries.filter(e => e.dosing.length > 0).length;

        console.log('[Dashboard] Parsing complete:');
        console.log('  - Total entries:', parsedEntries.length);
        console.log('  - With nitrate values:', nitrateCount);
        console.log('  - Feeding entries:', feedingCount);
        console.log('  - Dosing entries:', dosingCount);

        // Update status
        const cacheStatus = results.some(r => r.fromCache) ? ' (cached)' : '';
        statusEl.className = 'sync-status success';
        statusEl.textContent = `Synced ${parsedEntries.length} entries from ${loadedMonths.length} months${cacheStatus}`;

        return {
          entries: parsedEntries,
          loadedMonths,
          failedMonths,
          totalRaw: allEntries.length
        };

      } catch (error) {
        console.error('[Dashboard] Critical error fetching journal data:', error);
        console.error('[Dashboard] Error details:', {
          message: error.message,
          stack: error.stack,
          indexUrl: CONFIG.indexUrl
        });
        statusEl.className = 'sync-status error';
        statusEl.textContent = `Failed to load data: ${error.message}`;
        return null;
      }
    }

    // ====== DASHBOARD RENDERING ======

    function updateDataQuality(data) {
      const metricsEl = document.getElementById('qualityMetrics');

      const totalEntries = data.entries.length;
      const entriesWithNitrate = data.entries.filter(e => e.nitrate !== null).length;
      const nitratePercent = Math.round((entriesWithNitrate / totalEntries) * 100);

      const uniqueDates = new Set(data.entries.map(e => e.date)).size;
      const firstDate = data.entries[0]?.date;
      const lastDate = data.entries[data.entries.length - 1]?.date;

      // Calculate days tracked
      let daysTracked = 0;
      if (firstDate && lastDate) {
        const first = new Date(firstDate);
        const last = new Date(lastDate);
        daysTracked = Math.floor((last - first) / (1000 * 60 * 60 * 24)) + 1;
      }

      metricsEl.innerHTML = `
        <div class="quality-item good">
          <span class="icon" aria-hidden="true">&#10003;</span>
          <span>${totalEntries} entries loaded from ${data.loadedMonths.length} months</span>
        </div>
        <div class="quality-item ${nitratePercent >= 50 ? 'good' : 'warn'}">
          <span class="icon" aria-hidden="true">${nitratePercent >= 50 ? '&#10003;' : '&#9888;'}</span>
          <span>${entriesWithNitrate} with nitrate values (${nitratePercent}%)</span>
        </div>
        <div class="quality-item info">
          <span class="icon" aria-hidden="true">&#9432;</span>
          <span>Tracking ${daysTracked} days (${firstDate} to ${lastDate})</span>
        </div>
        ${data.failedMonths.length > 0 ? `
        <div class="quality-item warn">
          <span class="icon" aria-hidden="true">&#9888;</span>
          <span>Failed to load: ${data.failedMonths.join(', ')}</span>
        </div>
        ` : ''}
      `;
    }

    function updateStats(data) {
      const entries = data.entries;
      const today = new Date();

      // Find feedings (exclude 'none')
      const feedings = entries.filter(e =>
        e.types.includes('Feeding') && e.feeding !== 'none'
      );

      // Find nitrate readings
      const nitrateEntries = entries.filter(e => e.nitrate !== null);

      // Find last water change
      const waterChanges = entries.filter(e =>
        e.types.includes('Maintenance') &&
        /water\s*change|wc/i.test(getEntryText(e.originalEntry))
      );

      const lastWC = waterChanges.length > 0 ? waterChanges[waterChanges.length - 1] : null;
      let daysSinceWC = '‚Äî';
      let lastWCDate = '‚Äî';

      if (lastWC) {
        const wcDate = new Date(lastWC.date + 'T00:00:00');
        daysSinceWC = Math.floor((today - wcDate) / (1000 * 60 * 60 * 24));
        lastWCDate = `Last: ${fmtFullDate(lastWC.date)}`;
      }

      // Update UI
      document.getElementById('totalFeedings').textContent = feedings.length;
      document.getElementById('daysSinceWC').textContent = daysSinceWC;
      document.getElementById('lastWCSub').textContent = lastWCDate;

      if (nitrateEntries.length > 0) {
        const latestNitrate = nitrateEntries[nitrateEntries.length - 1];
        document.getElementById('currentNitrate').textContent = latestNitrate.nitrate;
      }
    }

    // ====== CHART RENDERING ======

    Chart.register(ChartDataLabels);
    const gridColor = 'rgba(30, 144, 255, 0.12)';
    const tickColor = '#9bb0cc';

    let nitrateChart, feedingChart, dosingChart, activityChart;
    let nitrateDataCache = [];

    function renderNitrateChart(data) {
      const nitrateEntries = data.entries.filter(e => e.nitrate !== null);
      nitrateDataCache = nitrateEntries;

      const ctx = document.getElementById('nitrateChart').getContext('2d');

      // Calculate label step based on count
      const nCount = nitrateEntries.length;
      const labelStep = nCount > 18 ? 3 : nCount > 12 ? 2 : 1;

      if (nitrateChart) nitrateChart.destroy();

      nitrateChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: nitrateEntries.map(d => d.date),
          datasets: [{
            label: 'Nitrate (ppm)',
            data: nitrateEntries.map(d => d.nitrate),
            borderColor: '#3aa6ff',
            backgroundColor: 'rgba(58,166,255,0.18)',
            fill: true,
            tension: 0.35,
            borderWidth: 3,
            pointRadius: 5,
            pointHoverRadius: 8,
            pointBackgroundColor: '#3aa6ff',
            pointBorderColor: '#0a0e1a',
            pointBorderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            legend: {
              labels: { color: '#e4e6eb', font: { size: 13 } }
            },
            tooltip: {
              enabled: false,
              external: function(context) {
                showNitrateTooltip(context, nitrateEntries);
              }
            },
            datalabels: {
              formatter: (v, ctx) => {
                const i = ctx.dataIndex;
                return (i % labelStep === 0) ? fmtDate(ctx.chart.data.labels[i]) : '';
              },
              align: 'top',
              anchor: 'end',
              offset: 4,
              color: '#e8f3ff',
              font: { weight: '600', size: 10 },
              textStrokeColor: '#0a0e1a',
              textStrokeWidth: 3,
              clip: false
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              max: 50,
              grid: { color: gridColor },
              ticks: {
                color: tickColor,
                callback: (v) => `${v} ppm`
              }
            },
            x: {
              grid: { color: gridColor },
              ticks: { display: false }
            }
          }
        }
      });

      // Update screen reader summary
      const summary = document.getElementById('nitrate-summary');
      if (nitrateEntries.length > 0) {
        const min = Math.min(...nitrateEntries.map(e => e.nitrate));
        const max = Math.max(...nitrateEntries.map(e => e.nitrate));
        summary.textContent = `Chart showing nitrate levels ranging from ${min} to ${max} ppm across ${nitrateEntries.length} water tests from ${nitrateEntries[0].date} to ${nitrateEntries[nitrateEntries.length - 1].date}.`;
      }
    }

    function showNitrateTooltip(context, nitrateEntries) {
      const tooltipEl = document.getElementById('nitrateTooltip');
      const tooltipModel = context.tooltip;

      if (tooltipModel.opacity === 0) {
        tooltipEl.classList.remove('visible');
        return;
      }

      if (tooltipModel.dataPoints && tooltipModel.dataPoints.length > 0) {
        const dataPoint = tooltipModel.dataPoints[0];
        const entry = nitrateEntries[dataPoint.dataIndex];

        const journalLink = `${CONFIG.journalBaseUrl}#${entry.date}`;

        tooltipEl.innerHTML = `
          <div class="tooltip-date">${fmtFullDate(entry.date)}</div>
          <div class="tooltip-value">Nitrate: ${entry.nitrate} ppm</div>
          <div class="tooltip-snippet">"${entry.snippet}"</div>
          <a href="${journalLink}" class="tooltip-link">View Full Entry &rarr;</a>
        `;
      }

      const position = context.chart.canvas.getBoundingClientRect();
      const chartArea = context.chart.chartArea;

      let left = tooltipModel.caretX;
      let top = tooltipModel.caretY - 10;

      // Adjust position to stay within bounds
      if (left + 320 > chartArea.right) {
        left = chartArea.right - 330;
      }
      if (left < chartArea.left) {
        left = chartArea.left + 10;
      }

      tooltipEl.style.left = left + 'px';
      tooltipEl.style.top = top + 'px';
      tooltipEl.classList.add('visible');
    }

    // Hide tooltip when mouse leaves chart area
    document.getElementById('nitrateChart').addEventListener('mouseleave', () => {
      document.getElementById('nitrateTooltip').classList.remove('visible');
    });

    function renderFeedingChart(data) {
      const feedings = data.entries.filter(e =>
        e.types.includes('Feeding') && e.feeding && e.feeding !== 'none'
      );

      const feedingTypes = {};
      feedings.forEach(f => {
        const key = f.feeding.toLowerCase();
        feedingTypes[key] = (feedingTypes[key] || 0) + 1;
      });

      const ctx = document.getElementById('feedingChart').getContext('2d');

      if (feedingChart) feedingChart.destroy();

      feedingChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: Object.keys(feedingTypes),
          datasets: [{
            data: Object.values(feedingTypes),
            backgroundColor: ['#3aa6ff', '#00c4ff', '#5fb3ff', '#7ecbff', '#9bd8ff', '#00ced1', '#5f9ea0', '#87ceeb', '#4682b4'],
            borderColor: '#0a0e1a',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom',
              labels: { color: '#e4e6eb', padding: 14, font: { size: 11 } }
            },
            datalabels: {
              display: false
            }
          }
        }
      });

      // Update screen reader summary
      const summary = document.getElementById('feeding-summary');
      const types = Object.entries(feedingTypes).map(([type, count]) => `${type}: ${count}`).join(', ');
      summary.textContent = `Doughnut chart showing distribution of ${feedings.length} feedings: ${types}.`;
    }

    function renderDosingChart(data) {
      const dosingProducts = {};

      data.entries.forEach(entry => {
        entry.dosing.forEach(d => {
          dosingProducts[d.product] = (dosingProducts[d.product] || 0) + 1;
        });
      });

      const ctx = document.getElementById('dosingChart').getContext('2d');

      if (dosingChart) dosingChart.destroy();

      dosingChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: Object.keys(dosingProducts),
          datasets: [{
            label: 'Doses',
            data: Object.values(dosingProducts),
            backgroundColor: 'rgba(58,166,255,0.75)',
            borderColor: '#3aa6ff',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#e4e6eb' } },
            datalabels: { display: false }
          },
          scales: {
            y: { beginAtZero: true, grid: { color: gridColor }, ticks: { color: tickColor, stepSize: 5 } },
            x: { grid: { color: gridColor }, ticks: { color: tickColor, autoSkip: true, maxRotation: 0 } }
          }
        }
      });

      // Update screen reader summary
      const summary = document.getElementById('dosing-summary');
      const products = Object.entries(dosingProducts).map(([product, count]) => `${product}: ${count}`).join(', ');
      summary.textContent = `Bar chart showing dosing frequency: ${products}.`;
    }

    function renderActivityChart(data) {
      const activityByDate = {};
      data.entries.forEach(e => {
        activityByDate[e.date] = (activityByDate[e.date] || 0) + 1;
      });

      const dates = Object.keys(activityByDate).sort();
      const values = dates.map(d => activityByDate[d]);

      const ctx = document.getElementById('activityChart').getContext('2d');

      if (activityChart) activityChart.destroy();

      activityChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: dates,
          datasets: [{
            label: 'Total Activities',
            data: values,
            backgroundColor: 'rgba(58,166,255,0.6)',
            borderColor: '#3aa6ff',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#e4e6eb' } },
            datalabels: { display: false }
          },
          scales: {
            y: { beginAtZero: true, grid: { color: gridColor }, ticks: { color: tickColor, stepSize: 1 } },
            x: {
              grid: { color: gridColor },
              ticks: {
                color: tickColor,
                autoSkip: true,
                maxRotation: 0,
                callback: function(value, index) {
                  return index % 3 === 0 ? fmtDate(dates[index]) : '';
                }
              }
            }
          }
        }
      });

      // Update screen reader summary
      const summary = document.getElementById('activity-summary');
      summary.textContent = `Bar chart showing daily activities across ${dates.length} days from ${dates[0]} to ${dates[dates.length - 1]}.`;
    }

    // ====== TIMELINE RENDERING ======

    function renderTimelines(data) {
      // Milestones
      const milestones = data.entries.filter(e => e.isMilestone || e.types.includes('Checkpoint'));
      const milestonesHTML = milestones.map(m => {
        const journalLink = `${CONFIG.journalBaseUrl}#${m.date}`;
        return `
          <div class="timeline-item milestone">
            <div class="timeline-date">${fmtFullDate(m.date)}</div>
            <div class="timeline-type">${m.types[0] || 'Milestone'}</div>
            <div class="timeline-content">
              <strong>${m.title}</strong><br/>
              ${m.snippet}
            </div>
            <a href="${journalLink}" class="timeline-link">View Full Entry &rarr;</a>
          </div>
        `;
      }).join('');
      document.getElementById('milestones').innerHTML = milestonesHTML || '<p style="color:#6b7c99;">No milestones recorded yet.</p>';

      // Recent activity (last 15)
      const recentActivity = data.entries.slice(-15).reverse();
      const activityHTML = recentActivity.map(a => {
        const journalLink = `${CONFIG.journalBaseUrl}#${a.date}`;
        return `
          <div class="timeline-item">
            <div class="timeline-date">${fmtFullDate(a.date)}</div>
            <div class="timeline-type">${a.types[0] || 'Activity'}</div>
            <div class="timeline-content">
              <strong>${a.title}</strong><br/>
              ${a.snippet}
            </div>
            <a href="${journalLink}" class="timeline-link">View Full Entry &rarr;</a>
          </div>
        `;
      }).join('');
      document.getElementById('recentActivity').innerHTML = activityHTML;
    }

    // ====== INITIALIZATION ======

    async function initializeDashboard() {
      console.log('[Dashboard] === DASHBOARD INITIALIZATION STARTED ===');
      console.log('[Dashboard] DOM ready state:', document.readyState);
      console.log('[Dashboard] Current time:', new Date().toISOString());

      const data = await fetchAllJournalData();

      if (!data) {
        // Show error state
        console.error('[Dashboard] No data returned, showing error state');
        document.getElementById('qualityMetrics').innerHTML = `
          <div class="quality-item warn">
            <span class="icon" aria-hidden="true">&#9888;</span>
            <span>Failed to load journal data. Please refresh the page.</span>
          </div>
        `;
        return;
      }

      console.log('[Dashboard] Rendering dashboard components...');

      // Render all components
      try {
        updateDataQuality(data);
        console.log('[Dashboard] Data quality updated');

        updateStats(data);
        console.log('[Dashboard] Stats updated');

        renderNitrateChart(data);
        console.log('[Dashboard] Nitrate chart rendered');

        renderFeedingChart(data);
        console.log('[Dashboard] Feeding chart rendered');

        renderDosingChart(data);
        console.log('[Dashboard] Dosing chart rendered');

        renderActivityChart(data);
        console.log('[Dashboard] Activity chart rendered');

        renderTimelines(data);
        console.log('[Dashboard] Timelines rendered');

        console.log('[Dashboard] === DASHBOARD INITIALIZATION COMPLETE ===');
      } catch (renderError) {
        console.error('[Dashboard] Error during rendering:', renderError);
        document.getElementById('syncStatus').className = 'sync-status error';
        document.getElementById('syncStatus').textContent = `Render error: ${renderError.message}`;
      }
    }

    // Start initialization when DOM is ready
    console.log('[Dashboard] Script loaded, DOM state:', document.readyState);
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeDashboard);
    } else {
      initializeDashboard();
    }
  </script>
  </main>
  <script src="/js/footer-loader.js?v=1.5.2" defer></script>
  <section class="legal-links" aria-label="Site legal links">
    <a href="/privacy-legal.html">Privacy Policy</a>
    <a href="/terms.html">Terms</a>
    <a href="/contact-feedback.html">Contact</a>
  </section>
  <noscript>
    <p class="legal-links__noscript">JavaScript is disabled. Visit our <a href="/privacy-legal.html">Privacy Policy</a> and
      <a href="/terms.html">Terms</a>.</p>
  </noscript>

  <div id="site-footer" data-footer-src="/footer.html?v=1.5.2"></div>
<!-- === TTG CMP Consent Bridge START === -->
<script>
(function(){
  // Helper: map TCF consent to our single "ads granted" flag.
  // We consider "granted" only when Purpose 1 (storage) AND Purpose 4 (select personalised ads)
  // are consented. If you want to allow NON-personalised ads when only Purpose 1 is granted,
  // set allowNPA=true below.
  var allowNPA = true; // if true, we‚Äôll treat Purpose 1 only as "granted" for showing slots (Google will serve NPA ads).

  function setAdConsent(granted){
    // Google CMP interface (Funding Choices) ‚Äî set consent for ads_storage and ad_user_data
    var consentState = granted ? 'granted' : 'denied';
    var payload = {
      'ad_storage': consentState,
      'ad_user_data': consentState,
      'ad_personalization': consentState
    };
    if (typeof window.__ttgUpdateConsentState__ === 'function') {
      window.__ttgUpdateConsentState__(payload);
    } else if (typeof window.gtag === 'function') {
      window.gtag('consent', 'update', payload);
    } else {
      (window.__ttgDeferredConsentUpdates__ = window.__ttgDeferredConsentUpdates__ || []).push(payload);
    }
  }

  function hookTCF(){
    // Funding Choices exposes the IAB TCF v2 interface.
    // We hook into it to map Purpose consent to Google consent mode.
    if (typeof __tcfapi !== 'function') return;

    __tcfapi('addEventListener', 2, function(tcData, success){
      if(!success || !tcData || tcData.eventStatus !== 'tcloaded') return;

      // Purpose IDs: 1 = Storage and Access, 4 = Select Personalised Ads
      var p1 = tcData.purpose && tcData.purpose.consents ? tcData.purpose.consents[1] : false;
      var p4 = tcData.purpose && tcData.purpose.consents ? tcData.purpose.consents[4] : false;

      var granted = allowNPA ? (p1 && (p4 || true)) : (p1 && p4);
      setAdConsent(granted);
    });
  }

  // Initialize once Funding Choices loads the TCF stub
  if (typeof __tcfapi === 'function') {
    hookTCF();
  } else {
    window.addEventListener('tcfapiReady', hookTCF, { once: true });
  }
})();
</script>
<!-- === TTG CMP Consent Bridge END === -->
</body>
</html>
